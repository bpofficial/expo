const path = require('path');
const fs = require('fs');

let sdkVersion = process.env.DOCS_VERSION || require('../package.json').version;
if (sdkVersion === 'unversioned') {
  // www API calls expect UNVERSIONED in all caps
  sdkVersion = 'UNVERSIONED';
} else {
  // Remove the leading 'v' for numeric versions
  sdkVersion = sdkVersion.includes('v') ? sdkVersion.substring(1) : sdkVersion;
}

// Stop now if outside of our monorepo
try {
  fs.statSync(`../server/www/xdl-schemas/${sdkVersion}-schema.json`);
  console.log('Schema file found, re-generating configuration docs');
} catch(e) {
  process.exit(0);
}

let ExpSchema;
try {
  ExpSchema = require(`../../server/www/xdl-schemas/${sdkVersion}-schema.json`).schema;
} catch (e) {
  console.error(e.toString());
  return;
}

let rawPath;
let filePath;
if (!process.argv[2]) {
  rawPath = `versions/v${sdkVersion}/guides/configuration.md`;
  filePath = path.resolve(rawPath);
  console.log('Using default target file path: ' + filePath.toString());
} else {
  rawPath = process.argv[2];
  filePath = path.resolve(rawPath);
}

const stream = fs.createWriteStream(filePath);

const preamble = `
\`exp.json\` is your go-to place for configuring parts of your app that don't belong in code. It is located at the root of your project next to your \`package.json\`.  The following is a full list of properties available to you.\
\n
`;

// Open and write!
stream.once('open', function(fd) {
  const readableSchema = [];
  Object.keys(ExpSchema.properties).forEach(key => {
    if (shouldDisplayProperty(ExpSchema.properties[key])) {
      readableSchema.push(extractData(key, ExpSchema.properties[key], ExpSchema));
    }
  });

  stream.write("---\n");
  stream.write("title: Configuration with exp.json\n");
  stream.write("---\n");

  stream.write(preamble);
  writePropertiesToStream(stream, readableSchema);
  stream.end();
});

function writePropertiesToStream(stream, schema, depth = 0) {
  schema.forEach(prop => {
    let depthSpacing = (new Array(depth)).join(' ');
    stream.write(`\n${depthSpacing}- \`${prop.key}\`\n`);
    stream.write(`\n${depthSpacing}   ${propertyDescription(prop, depthSpacing)}`);
    if (prop.children) {
      writePropertiesToStream(stream, prop.children, depth + 4);
    }
  });
}

/* Helper functions */

function propertyDescription(prop, depthSpacing) {
  let result = '';

  if (prop.isRequired) {
    result += '**Required**. ';
  }

  if (prop.isStandaloneOnly) {
    result += '**Standalone Apps Only**. ';
  }

  if (prop.description) {
    result += `${prop.description}\n`;
  }

  if (prop.validOptions) {
    result += `${depthSpacing} ${prop.validOptions}\n`;
  }

  return result;
}

function shouldDisplayProperty(property) {
  if (property.meta && property.meta.autogenerated) {
    return false;
  }

  return true;
}

function extractValidOptions(property) {
  if (property.enum && property.enum.length) {
    return property.enum.join(', ');
  } else if (property.meta && property.meta.regexHuman) {
    return property.meta.regexHuman;
  }
}

function determineIfStandaloneOnly(property) {
  return property.meta && property.meta.standaloneOnly;
}

function extractData(key, property, parent) {
  let description = (property.description || '').trim();
  let type = property.type;
  let validOptions = extractValidOptions(property);
  let isRequired = parent.required && parent.required.includes(key);
  let isStandaloneOnly = determineIfStandaloneOnly(property);

  let data = {
    description,
    isRequired,
    isStandaloneOnly,
    key,
    type,
    validOptions,
  };

  let children = property.properties;
  if (children) {
    let mappedChildren = [];
    Object.keys(children).forEach(key => {
      if (shouldDisplayProperty(children[key])) {
        mappedChildren.push(extractData(key, children[key], property));
      }
    });
    data = Object.assign(data, {children: mappedChildren});
  }

  return data;
}
